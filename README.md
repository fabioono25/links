Table of Contents
* [Functional Programming](#functional-programming)
* [Big-O Notation](#big-o-notation)

### Functional Programming

Software sem bugs, reduzindo falhas em produção com práticas de programação funcional (em C#) - Elemar Junior
https://www.infoq.com/br/presentations/software-sem-bugs-reduzindo-falhas-em-producao-com-programacao-funcional?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global

- Abordagem declarativa vs imperativa
- Imutabilidade (vantagens na programação paralela)
- Caching Intensivo
- High-order functions
- Lazyness
- Option
- Either (validações garantidas por design)
- Functions (funções com implementações concretas ao invés de classes)

### Big-O Notation

https://www.youtube.com/watch?v=__vX2sjlpXU&vl=pt
http://www.corejavainterviewquestions.com/idiots-guide-big-o/

- Simplify analysis of an algorithm's efficiency;
- Types of measurement (worst, best, average case);
- O(1)/Constant Complexity: constant time - irrelevant of the size of the data - Queue;
- O(log n)/Logarithmic Complexity: grows but not proportionately;
- O(n)/Linear Complexity: time taken grows proportionately;
- O(n log n): Logarithmic + Linear, normally there's 2 parts of the sort;
- O(n^2)/Quadratic Complexity: extra slow
- O(2^n)/Exponential Growth: algorithm takes twice as long for every new element added;
- O(1) -> O(n) -> O(n^2)

![](https://github.com/fabioono25/links/blob/master/images/bigO_complexity.PNG)
